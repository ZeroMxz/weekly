参考连接：https://zhuanlan.zhihu.com/p/25816426
### 栈溢出理论
#### 简介
栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段
#### 条件
第一 程序要有向栈内写入数据的行为
第二 程序并不限制写入数据的长度

#### 函数调用栈
函数调用栈：程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量
发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶
函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。
函数调用栈在内存中从高地址向低地址生长

#### 函数状态
三个寄存器
esp：用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。
ebp：用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置
eip：用来存储即将执行的程序指令的地址，cpu按照eip的存储内容读取指令并执行，eip随之指向相邻的下一条指令。

#### 函数调用
函数调用的变化核心是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态
1.将 被调用函数（callee）的参数按照逆序压入栈内（如没有参数则跳过这一步），这些函数参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。
2.将调用之后的下一条指令地址作为返回地址压入栈内。（caller的eip信息保存）
3.将当前ebp寄存器的值（调用函数的基地址）压入栈内，并将ebp寄存器的值更新为当前栈顶地址(caller的ebp信息得以保存)，及ebp被更新为被调用函数（callee）的基地址
4.将 被调用函数（callee）的局部变量等数据压入栈内。

调用结束的变化核心是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态
1.局部变量弹出，栈顶指向调用函数（callee）的基地址
2.基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到ebp寄存器内。这样调用函数（caller）的ebp（基地址）信息得到恢复，此时栈顶会指向返回地址。
3.再将返回地址从栈内弹出，并存到eip寄存器内。这样调佣函数（caller）的eip（指令）信息得以恢复。
4.状态全部恢复

#### 技术核心思路
函数正在执行内部指令的过程中无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这是才可以通过修改函数状态来实现攻击，而控制程序执行指令最关键的寄存器是eip，所以我们的目标就是**让eip载入攻击指令的地址**

**核心目的是用攻击指令的地址来覆盖返回地址**

技术大致可概括为
修改返回地址，让其指向溢出数据中的一段指令（**shellcode**）
修改返回地址，让其指向内存中的有的某个函数（**return2libc**）
修改返回地址，让其指向内存中已有的一段指令（**ROP**）
修改某个被调用的函数的地址，让其指向另一个函数（**hijack GOT**）

### Shellcode
#### 基础知识
攻击指令一般都是用来打开shell，从而获得当前进程的控制权
shellcode可以用汇编语言来写再转成对应的机器码。

#### 溢出数据
**payload**：padding1+address of shellcode+padding2+shellcode

（填充数据不要包含 `\x00`,截断）
padding1 随意填充 长度刚好覆盖函数的基地址
address of shellcode 后面shellcode起始处的地址，用来覆盖返回地址
padding2 随意填充 长度任意
shellcode 十六进制的机器码格式

##### 如何确定padding1长度
1.使用调试工具查看汇编代码来确定
2.在运行程序时用不断增加长度的方法来试探（如果返回地址被无效地址，例如AAAA覆盖，程序会终止报错）

##### shellcode起始地址应该是多少
1.在调试工具里查看返回值地址的位置（因为运行时环境和调试工具有所不同，所以只能得到一个大概的位置）
2.在padding2中填充若干长度的`\x90`(NOP,No Operation)，让CPU跳到下一条指令，只要返回地址能命中这一段中的任意位置，就可以无副作用一路跳转到shellcode起始处
3.在没有内存布局随机化技术（ASLR）时，每次运行函数返回地址都是相同的，可以通过无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定shellcode的起始地址

##### 可用前提
函数调用栈上的数据（shellcode）要有可执行权限
否则只能尝试内存里已有的指令或函数，及使用return2libc和ROP

### Return2libc
#### 基础知识
由于libc动态链接库中的函数被广泛使用，所以大概率在内存中找得到该动态库，同时，该库包含一些系统级函数，所以通常使用这些系统级函数来获得当前进程的控制权。

因为执行的函数可能需要参数，所以调用system()函数打开shell的完整形式为system("/bin/sh")，所以溢出数据也要包含必要的参数

#### 溢出数据
payload：padding1+address of system()+padding2+address of "/bin/sh"

##### system()函数的地址应该是多少
在ASLR被关闭的前提下，可以通过调试工具直接查看system()的地址，也可以查看动态库在内存中的起始地址，再在动态库内查看函数的相对偏移量，通过计算得到函数的绝对地址。

##### "/bin/sh"在哪
可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址

##### 局限性
同上，仅适用ASLR被关闭的情况下。