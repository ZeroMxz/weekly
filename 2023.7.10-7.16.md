### Hijack GOT
修改某个被调用函数的地址，让其指向另一个函数。

#### 原理
程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。

全局偏移量表 GOT（Global Offset Table），用来存储外部函数在内存的确切地址。GOT存储在数据段（Data Segment）内，可以在程序运行中被修改。
程序链接表 PLT（Procedure Linkage Table），用来存储外部函数的入口点，程序总会到PLT这里寻找外部函数的地址。PLT存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以PLT并不会知道程序运行时动态链接库被加载的确切位置。PLT表内存储的入口点就是GOT表中对应条目的地址。

##### LAZY设计思想
将需要完成的操作（解析外部函数的内存地址）留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。

GOT 表的初始值都指向 PLT 表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT 表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。

#### 攻击思路
确定函数A在GOT表中的条目位置，确定函数B在内存中的地址，将函数B的地址写入函数A在GOT表中的条目

##### 如何确定函数A在GOT表中的条目位置
程序调用函数时，通过PLT表跳转到GOT表的对应条目，可以在函数调佣的汇编指令中找到PLT表中该函数的入口位置，从而定位到该函数在GOT中的条目
例如
`call 0x08048430 <printf@plt>`
就说明printf在PLT表中的入口点在 _0x08048430_ ，所以 _0x08048430_ 处存储的就是 GOT 表中 printf 的条目地址

##### 如何确定函数B在内存中的地址
函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数 A 的运行时地址（读取 GOT 表内容），也知道函数 A 和函数 B 在动态链接库内的相对位置，就可以推算出函数 B 的运行时地址。

##### 如何实现GOT表中数据的修改
使用ROP

### 防御措施
1.程序在默认编译设置下都会取消栈上数据的可执行权限，这样简单的 shellcode 溢出攻击就无法实现了
2.在操作系统内开启内存布局随机化（ASLR），这样可以增大确定堆栈内数据和动态库内函数的内存地址的难度。
3.编译程序时还可以设置某些编译选项，使程序在运行时会在函数栈上的 ebp 地址和返回地址之间生成一个特殊的值，这个值被称为“金丝雀”（关于这个典故，请大家自行谷歌）。这样一旦发生了栈溢出并覆盖了返回地址，这个值就会被改写，从而实现函数栈的越界检查。